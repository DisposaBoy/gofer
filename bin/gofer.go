package main

import (
  "fmt"
  "go/ast"
  "go/parser"
  "go/token"
  "io"
  "os"
  "os/exec"
  "path"
  "path/filepath"
  "strings"
  "text/template"
  "time"
)

type Import struct {
  Path string
}

type TaskData struct {
  Imports []Import
}

// Gofer binary constants.
const (
  SOURCE_PREFIX        = "/src/"
  PACKAGE_NAME         = "tasks"
  EXPECTED_IMPORT      = "gofer"
  TEMPLATE_DESTINATION = "gofer_task_definitions_%v.go"
)

// Gofer binary variables.
var (
  GoPath          = os.Getenv("GOPATH") // The users GOPATH environment variable.
  TaskDirectories = make([]string, 0)   // Task directories.
  Data            = TaskData{}          // Data to be used during template generation.
)

// Runnable template.
var Template = template.Must(template.New("gofer").Parse(`
  // This file was generated by gofer.
  // copyright (c) Chuck Preslar, 2013.
  package main

  import (
    // Standard library packages.

    "errors"
    "fmt"
    "os"
    "regexp"

    // Gofer package.

    "github.com/chuckpreslar/gofer"

    // Imported task packages.
  {{range .Imports}}
    _ "{{.Path}}"
  {{end}}
  )

  type Command struct {
    Name        string // Name of the command.
    Trigger     string // Trigger that causes the command to execute.
    Description string // Description for the command.
  }

  // Gofer CLI errors.
  var (
    ErrInvalidArguments = errors.New("Invalid arguments") // An invalid argument was passed to the CLI.
    ErrUknownCommand    = errors.New("Unknown command")   // An unkown command was passed to the CLI.
  )

  // Gofer CLI commands.
  var (
    TasksCommand = Command{
      Name:        "tasks",
      Trigger:     "tasks",
      Description: "Prints a list of avaiable gofer tasks.",
    }

    PreformCommand = Command{
      Name:        "preform",
      Trigger:     "([a-zA-Z0-9]+):([a-zA-Z0-9]+)",
      Description: "Runs a gofer task.",
    }

    VersionCommand = Command{
      Name:        "version",
      Trigger:     "version",
      Description: "Prints the gofer version installed.",
    }
  )

  var Commands = []Command{
    TasksCommand,
    PreformCommand,
    VersionCommand,
  }

  func main() {
    arguments := os.Args[1:]

    if 0 == len(arguments) {
      fmt.Fprintf(os.Stderr, "%s\n", ErrInvalidArguments)
      os.Exit(0)
    }

    trigger := arguments[0]

    var err error
    
    for _, command := range Commands {
      if regexp.MustCompile(command.Trigger).MatchString(trigger) {
        switch command.Name {
        case "tasks":
          err = gofer.ListTasks(os.Stdout, arguments...)
        case "preform":
          err = gofer.Preform(arguments...)
        case "version":
          gofer.PrintVersion(os.Stdout)
        default:
          fmt.Fprintf(os.Stderr, "%s\n", ErrUknownCommand)
          os.Exit(0)
        }
      }
    }

    if nil != err {
      fmt.Fprintf(os.Stderr, "%s\n", err)
    }
  }
`))

// WalkGoPath attempts to walk folders located in the local
// GOPATH, adding any directory
func WalkGoPath() error {
  err := filepath.Walk(GoPath, func(path string, info os.FileInfo, err error) error {
    if info.IsDir() && strings.HasSuffix(path, PACKAGE_NAME) {
      TaskDirectories = append(TaskDirectories, path)
    }

    return err
  })

  return err
}

func ParseTaskDirectories() error {
  for _, dir := range TaskDirectories {
    fset := token.NewFileSet()
    packages, err := parser.ParseDir(fset, dir, nil, parser.AllErrors)

    if nil != err {
      return err
    }

    if err = ParsePackages(packages, dir); nil != err {
      return err
    }
  }

  return nil
}

func ParsePackages(packages map[string]*ast.Package, dir string) (err error) {
  for _, pkg := range packages {
    file := ast.MergePackageFiles(pkg, ast.FilterImportDuplicates)

    if IsGoferTaskFile(file) {
      AddImport(dir)
    }
  }
  return
}

func IsGoferTaskFile(file *ast.File) bool {
  for _, imprt := range file.Imports {
    if PACKAGE_NAME == file.Name.String() && strings.ContainsAny(imprt.Path.Value, EXPECTED_IMPORT) {
      return true
    }
  }

  return false
}

func AddImport(dir string) {
  imprt := strings.TrimLeft(strings.Replace(dir, GoPath, "", 1), SOURCE_PREFIX)
  Data.Imports = append(Data.Imports, Import{imprt})
}

func WriteRunnable(destination string) (err error) {
  file, err := os.Create(destination)

  if nil != err {
    return
  }

  defer file.Close()

  err = Template.Execute(file, Data)

  return
}

func RemoveRunnable(location string) {
  os.Remove(location)
}

func main() {
  err := WalkGoPath()

  if nil != err {
    panic(err)
  }

  err = ParseTaskDirectories()

  if nil != err {
    panic(err)
  }

  dir := path.Join(os.TempDir(), fmt.Sprintf(TEMPLATE_DESTINATION, time.Now().Unix()))

  err = WriteRunnable(dir)

  if nil != err {
    panic(err)
  }

  defer RemoveRunnable(dir)

  arguments := append([]string{"run", dir}, os.Args[1:]...)

  command := exec.Command("go", arguments...)

  stdout, err := command.StdoutPipe()

  if nil != err {
    panic(err)
  }

  stderr, err := command.StderrPipe()

  if nil != err {
    panic(err)
  }

  err = command.Start()

  if nil != err {
    panic(err)
  }

  go io.Copy(os.Stdout, stdout)
  go io.Copy(os.Stderr, stderr)

  err = command.Wait()

  if nil != err {
    panic(err)
  }
}
